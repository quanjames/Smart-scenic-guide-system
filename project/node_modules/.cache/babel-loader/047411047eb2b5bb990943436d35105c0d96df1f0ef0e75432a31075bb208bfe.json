{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Tree data structure\n */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport linkSeriesData from './helper/linkSeriesData.js';\nimport SeriesData from './SeriesData.js';\nimport prepareSeriesDataSchema from './helper/createDimensions.js';\nimport { convertOptionIdName } from '../util/model.js';\nvar TreeNode = /** @class */\nfunction () {\n  function TreeNode(name, hostTree) {\n    this.depth = 0;\n    this.height = 0;\n    /**\n     * Reference to list item.\n     * Do not persistent dataIndex outside,\n     * besause it may be changed by list.\n     * If dataIndex -1,\n     * this node is logical deleted (filtered) in list.\n     */\n\n    this.dataIndex = -1;\n    this.children = [];\n    this.viewChildren = [];\n    this.isExpand = false;\n    this.name = name || '';\n    this.hostTree = hostTree;\n  }\n  /**\n   * The node is removed.\n   */\n\n  TreeNode.prototype.isRemoved = function () {\n    return this.dataIndex < 0;\n  };\n  TreeNode.prototype.eachNode = function (options, cb, context) {\n    if (zrUtil.isFunction(options)) {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n    options = options || {};\n    if (zrUtil.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n    order === 'postorder' && cb.call(context, this);\n  };\n  /**\n   * Update depth and height of this subtree.\n   */\n\n  TreeNode.prototype.updateDepthAndHeight = function (depth) {\n    var height = 0;\n    this.depth = depth;\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n    this.height = height + 1;\n  };\n  TreeNode.prototype.getNodeById = function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n      if (res) {\n        return res;\n      }\n    }\n  };\n  TreeNode.prototype.contains = function (node) {\n    if (node === this) {\n      return true;\n    }\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n      if (res) {\n        return res;\n      }\n    }\n  };\n  /**\n   * @param includeSelf Default false.\n   * @return order: [root, child, grandchild, ...]\n   */\n\n  TreeNode.prototype.getAncestors = function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n    ancestors.reverse();\n    return ancestors;\n  };\n  TreeNode.prototype.getAncestorsIndices = function () {\n    var indices = [];\n    var currNode = this;\n    while (currNode) {\n      indices.push(currNode.dataIndex);\n      currNode = currNode.parentNode;\n    }\n    indices.reverse();\n    return indices;\n  };\n  TreeNode.prototype.getDescendantIndices = function () {\n    var indices = [];\n    this.eachNode(function (childNode) {\n      indices.push(childNode.dataIndex);\n    });\n    return indices;\n  };\n  TreeNode.prototype.getValue = function (dimension) {\n    var data = this.hostTree.data;\n    return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n  };\n  TreeNode.prototype.setLayout = function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  };\n  /**\n   * @return {Object} layout\n   */\n\n  TreeNode.prototype.getLayout = function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  }; // @depcrecated\n  // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  TreeNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  }; // TODO: TYPE More specific model\n\n  TreeNode.prototype.getLevelModel = function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  };\n  TreeNode.prototype.setVisual = function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  };\n  /**\n   * Get item visual\n   * FIXME: make return type better\n   */\n\n  TreeNode.prototype.getVisual = function (key) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key);\n  };\n  TreeNode.prototype.getRawIndex = function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  };\n  TreeNode.prototype.getId = function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  };\n  /**\n   * index in parent's children\n   */\n\n  TreeNode.prototype.getChildIndex = function () {\n    if (this.parentNode) {\n      var children = this.parentNode.children;\n      for (var i = 0; i < children.length; ++i) {\n        if (children[i] === this) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    return -1;\n  };\n  /**\n   * if this is an ancestor of another node\n   *\n   * @param node another node\n   * @return if is ancestor\n   */\n\n  TreeNode.prototype.isAncestorOf = function (node) {\n    var parent = node.parentNode;\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n      parent = parent.parentNode;\n    }\n    return false;\n  };\n  /**\n   * if this is an descendant of another node\n   *\n   * @param node another node\n   * @return if is descendant\n   */\n\n  TreeNode.prototype.isDescendantOf = function (node) {\n    return node !== this && node.isAncestorOf(this);\n  };\n  return TreeNode;\n}();\nexport { TreeNode };\n;\nvar Tree = /** @class */\nfunction () {\n  function Tree(hostModel) {\n    this.type = 'tree';\n    this._nodes = [];\n    this.hostModel = hostModel;\n  }\n  Tree.prototype.eachNode = function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  };\n  Tree.prototype.getNodeByDataIndex = function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  };\n  Tree.prototype.getNodeById = function (name) {\n    return this.root.getNodeById(name);\n  };\n  /**\n   * Update item available by list,\n   * when list has been performed options like 'filterSelf' or 'map'.\n   */\n\n  Tree.prototype.update = function () {\n    var data = this.data;\n    var nodes = this._nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  /**\n   * Clear all layouts\n   */\n\n  Tree.prototype.clearLayouts = function () {\n    this.data.clearItemLayouts();\n  };\n  /**\n   * data node format:\n   * {\n   *     name: ...\n   *     value: ...\n   *     children: [\n   *         {\n   *             name: ...\n   *             value: ...\n   *             children: ...\n   *         },\n   *         ...\n   *     ]\n   * }\n   */\n\n  Tree.createTree = function (dataRoot, hostModel, beforeLink) {\n    var tree = new Tree(hostModel);\n    var listData = [];\n    var dimMax = 1;\n    buildHierarchy(dataRoot);\n    function buildHierarchy(dataNode, parentNode) {\n      var value = dataNode.value;\n      dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);\n      listData.push(dataNode);\n      var node = new TreeNode(convertOptionIdName(dataNode.name, ''), tree);\n      parentNode ? addChild(node, parentNode) : tree.root = node;\n      tree._nodes.push(node);\n      var children = dataNode.children;\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          buildHierarchy(children[i], node);\n        }\n      }\n    }\n    tree.root.updateDepthAndHeight(0);\n    var dimensions = prepareSeriesDataSchema(listData, {\n      coordDimensions: ['value'],\n      dimensionsCount: dimMax\n    }).dimensions;\n    var list = new SeriesData(dimensions, hostModel);\n    list.initData(listData);\n    beforeLink && beforeLink(list);\n    linkSeriesData({\n      mainData: list,\n      struct: tree,\n      structAttr: 'tree'\n    });\n    tree.update();\n    return tree;\n  };\n  return Tree;\n}();\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n */\n\nfunction addChild(child, node) {\n  var children = node.children;\n  if (child.parentNode === node) {\n    return;\n  }\n  children.push(child);\n  child.parentNode = node;\n}\nexport default Tree;","map":{"version":3,"names":["zrUtil","linkSeriesData","SeriesData","prepareSeriesDataSchema","convertOptionIdName","TreeNode","name","hostTree","depth","height","dataIndex","children","viewChildren","isExpand","prototype","isRemoved","eachNode","options","cb","context","isFunction","isString","order","attr","suppressVisitSub","call","i","length","updateDepthAndHeight","child","getNodeById","id","getId","len","res","contains","node","getAncestors","includeSelf","ancestors","parentNode","push","reverse","getAncestorsIndices","indices","currNode","getDescendantIndices","childNode","getValue","dimension","data","getStore","get","getDimensionIndex","setLayout","layout","merge","setItemLayout","getLayout","getItemLayout","getModel","path","itemModel","getItemModel","getLevelModel","levelModels","setVisual","key","value","setItemVisual","getVisual","getItemVisual","getRawIndex","getChildIndex","isAncestorOf","parent","isDescendantOf","Tree","hostModel","type","_nodes","root","getNodeByDataIndex","rawIndex","update","nodes","count","clearLayouts","clearItemLayouts","createTree","dataRoot","beforeLink","tree","listData","dimMax","buildHierarchy","dataNode","Math","max","isArray","addChild","dimensions","coordDimensions","dimensionsCount","list","initData","mainData","struct","structAttr"],"sources":["F:/idea_Project_2023/design_3/project/node_modules/echarts/lib/data/Tree.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Tree data structure\n */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport linkSeriesData from './helper/linkSeriesData.js';\nimport SeriesData from './SeriesData.js';\nimport prepareSeriesDataSchema from './helper/createDimensions.js';\nimport { convertOptionIdName } from '../util/model.js';\n\nvar TreeNode =\n/** @class */\nfunction () {\n  function TreeNode(name, hostTree) {\n    this.depth = 0;\n    this.height = 0;\n    /**\n     * Reference to list item.\n     * Do not persistent dataIndex outside,\n     * besause it may be changed by list.\n     * If dataIndex -1,\n     * this node is logical deleted (filtered) in list.\n     */\n\n    this.dataIndex = -1;\n    this.children = [];\n    this.viewChildren = [];\n    this.isExpand = false;\n    this.name = name || '';\n    this.hostTree = hostTree;\n  }\n  /**\n   * The node is removed.\n   */\n\n\n  TreeNode.prototype.isRemoved = function () {\n    return this.dataIndex < 0;\n  };\n\n  TreeNode.prototype.eachNode = function (options, cb, context) {\n    if (zrUtil.isFunction(options)) {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n\n    options = options || {};\n\n    if (zrUtil.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n\n    order === 'postorder' && cb.call(context, this);\n  };\n  /**\n   * Update depth and height of this subtree.\n   */\n\n\n  TreeNode.prototype.updateDepthAndHeight = function (depth) {\n    var height = 0;\n    this.depth = depth;\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n\n    this.height = height + 1;\n  };\n\n  TreeNode.prototype.getNodeById = function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n\n      if (res) {\n        return res;\n      }\n    }\n  };\n\n  TreeNode.prototype.contains = function (node) {\n    if (node === this) {\n      return true;\n    }\n\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n\n      if (res) {\n        return res;\n      }\n    }\n  };\n  /**\n   * @param includeSelf Default false.\n   * @return order: [root, child, grandchild, ...]\n   */\n\n\n  TreeNode.prototype.getAncestors = function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n\n    ancestors.reverse();\n    return ancestors;\n  };\n\n  TreeNode.prototype.getAncestorsIndices = function () {\n    var indices = [];\n    var currNode = this;\n\n    while (currNode) {\n      indices.push(currNode.dataIndex);\n      currNode = currNode.parentNode;\n    }\n\n    indices.reverse();\n    return indices;\n  };\n\n  TreeNode.prototype.getDescendantIndices = function () {\n    var indices = [];\n    this.eachNode(function (childNode) {\n      indices.push(childNode.dataIndex);\n    });\n    return indices;\n  };\n\n  TreeNode.prototype.getValue = function (dimension) {\n    var data = this.hostTree.data;\n    return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n  };\n\n  TreeNode.prototype.setLayout = function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  };\n  /**\n   * @return {Object} layout\n   */\n\n\n  TreeNode.prototype.getLayout = function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  }; // @depcrecated\n  // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  TreeNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  }; // TODO: TYPE More specific model\n\n\n  TreeNode.prototype.getLevelModel = function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  };\n\n  TreeNode.prototype.setVisual = function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  };\n  /**\n   * Get item visual\n   * FIXME: make return type better\n   */\n\n\n  TreeNode.prototype.getVisual = function (key) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key);\n  };\n\n  TreeNode.prototype.getRawIndex = function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  };\n\n  TreeNode.prototype.getId = function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  };\n  /**\n   * index in parent's children\n   */\n\n\n  TreeNode.prototype.getChildIndex = function () {\n    if (this.parentNode) {\n      var children = this.parentNode.children;\n\n      for (var i = 0; i < children.length; ++i) {\n        if (children[i] === this) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n\n    return -1;\n  };\n  /**\n   * if this is an ancestor of another node\n   *\n   * @param node another node\n   * @return if is ancestor\n   */\n\n\n  TreeNode.prototype.isAncestorOf = function (node) {\n    var parent = node.parentNode;\n\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return false;\n  };\n  /**\n   * if this is an descendant of another node\n   *\n   * @param node another node\n   * @return if is descendant\n   */\n\n\n  TreeNode.prototype.isDescendantOf = function (node) {\n    return node !== this && node.isAncestorOf(this);\n  };\n\n  return TreeNode;\n}();\n\nexport { TreeNode };\n;\n\nvar Tree =\n/** @class */\nfunction () {\n  function Tree(hostModel) {\n    this.type = 'tree';\n    this._nodes = [];\n    this.hostModel = hostModel;\n  }\n\n  Tree.prototype.eachNode = function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  };\n\n  Tree.prototype.getNodeByDataIndex = function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  };\n\n  Tree.prototype.getNodeById = function (name) {\n    return this.root.getNodeById(name);\n  };\n  /**\n   * Update item available by list,\n   * when list has been performed options like 'filterSelf' or 'map'.\n   */\n\n\n  Tree.prototype.update = function () {\n    var data = this.data;\n    var nodes = this._nodes;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  /**\n   * Clear all layouts\n   */\n\n\n  Tree.prototype.clearLayouts = function () {\n    this.data.clearItemLayouts();\n  };\n  /**\n   * data node format:\n   * {\n   *     name: ...\n   *     value: ...\n   *     children: [\n   *         {\n   *             name: ...\n   *             value: ...\n   *             children: ...\n   *         },\n   *         ...\n   *     ]\n   * }\n   */\n\n\n  Tree.createTree = function (dataRoot, hostModel, beforeLink) {\n    var tree = new Tree(hostModel);\n    var listData = [];\n    var dimMax = 1;\n    buildHierarchy(dataRoot);\n\n    function buildHierarchy(dataNode, parentNode) {\n      var value = dataNode.value;\n      dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);\n      listData.push(dataNode);\n      var node = new TreeNode(convertOptionIdName(dataNode.name, ''), tree);\n      parentNode ? addChild(node, parentNode) : tree.root = node;\n\n      tree._nodes.push(node);\n\n      var children = dataNode.children;\n\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          buildHierarchy(children[i], node);\n        }\n      }\n    }\n\n    tree.root.updateDepthAndHeight(0);\n    var dimensions = prepareSeriesDataSchema(listData, {\n      coordDimensions: ['value'],\n      dimensionsCount: dimMax\n    }).dimensions;\n    var list = new SeriesData(dimensions, hostModel);\n    list.initData(listData);\n    beforeLink && beforeLink(list);\n    linkSeriesData({\n      mainData: list,\n      struct: tree,\n      structAttr: 'tree'\n    });\n    tree.update();\n    return tree;\n  };\n\n  return Tree;\n}();\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n */\n\n\nfunction addChild(child, node) {\n  var children = node.children;\n\n  if (child.parentNode === node) {\n    return;\n  }\n\n  children.push(child);\n  child.parentNode = node;\n}\n\nexport default Tree;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}