{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\nfunction getGroupIdDimension(data) {\n  var dimensions = data.dimensions;\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {\n      return dimensions[i];\n    }\n  }\n}\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n      return;\n    }\n    var indices = data.getIndices();\n    var groupDim = getGroupIdDimension(data);\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        dataGroupId: seriesInfo.dataGroupId,\n        data: data,\n        dim: seriesInfo.dim || groupDim,\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\nfunction stopAnimation(el) {\n  el.stopAnimation();\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from ?\n        // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n  function findKeyDim(items) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].dim) {\n        return items[i].dim;\n      }\n    }\n  }\n  var oldKeyDim = findKeyDim(oldDiffItems);\n  var newKeyDim = findKeyDim(newDiffItems);\n  var hasMorphAnimation = false;\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      } // Use group id as transition key by default.\n      // So we can achieve multiple to multiple animation like drilldown / up naturally.\n      // If group id not exits. Use id instead. If so, only one to one transition will be applied.\n\n      var dataGroupId = diffItem.dataGroupId; // If specified key dimension(itemGroupId by default). Use this same dimension from other data.\n      // PENDING: If only use key dimension of newData.\n\n      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;\n      var dimInfo = keyDim && data.getDimensionInfo(keyDim);\n      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n      if (dimInfo) {\n        // Get from encode.itemGroupId.\n        var key = data.get(dimInfo.name, dataIndex);\n        if (dimOrdinalMeta) {\n          return dimOrdinalMeta.categories[key] || key + '';\n        }\n        return key + '';\n      } // Get groupId from raw item. { groupId: '' }\n\n      var itemVal = data.getRawDataItem(dataIndex);\n      if (itemVal && itemVal.groupId) {\n        return itemVal.groupId + '';\n      }\n      return dataGroupId || data.getId(dataIndex);\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n    if (\n    // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n    if (newEl) {\n      stopAnimation(newEl);\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide,\n        // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n  return seriesKey;\n}\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n  return seriesKey;\n}\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n    if (found) {\n      return i;\n    }\n  }\n}\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        dim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        dim: finder.dimension\n      });\n    }\n  });\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}","map":{"version":3,"names":["SERIES_UNIVERSAL_TRANSITION_PROP","createHashMap","each","map","filter","isArray","extend","applyMorphAnimation","getPathList","Path","initProps","DataDiffer","makeInner","normalizeToArray","warn","getAnimationConfig","getOldStyle","Displayable","DATA_COUNT_THRESHOLD","getUniversalTransitionGlobalStore","getGroupIdDimension","data","dimensions","i","length","dimInfo","getDimensionInfo","otherDims","itemGroupId","flattenDataDiffItems","list","items","seriesInfo","count","process","env","NODE_ENV","indices","getIndices","groupDim","dataIndex","push","dataGroupId","dim","divide","fadeInElement","newEl","newSeries","newIndex","traverse","el","style","opacity","isFrom","removeEl","parent","computedTransform","getComputedTransform","setLocalTransform","remove","stopAnimation","isGroup","child","animateElementStyles","seriesModel","animationConfig","oldStyle","animateFrom","isAllIdSame","oldDiffItems","newDiffItems","len","oldItem","newItem","getId","transitionBetween","oldList","newList","api","updateMorphingPathProps","from","to","rawFrom","rawTo","animationCfg","findKeyDim","oldKeyDim","newKeyDim","hasMorphAnimation","createKeyGetter","isOld","onlyGetId","diffItem","keyDim","dimOrdinalMeta","ordinalMeta","key","get","name","categories","itemVal","getRawDataItem","groupId","useId","isElementStillInChart","getItemGraphicEl","id","updateOneToOne","oldIndex","hostModel","oldEl","update","updateManyToOne","oldIndices","newData","oldElsList","idx","updateOneToMany","newIndices","newElsList","newSeris","updateManyToMany","rawIdx","execute","_a","view","getViewOfSeriesModel","isAnimationEnabled","duration","group","animators","getSeriesTransitionKey","series","seriesKey","getModel","convertArraySeriesKeyToString","sort","join","getDivideShapeFromData","findTransitionSeriesBatches","globalStore","params","updateBatches","oldDataMap","oldDataMapForSplit","oldSeries","oldDataGroupId","oldDataGroupIds","oldData","transitionKey","transitionKeyStr","set","checkTransitionSeriesKeyDuplicated","updatedSeries","isUniversalTransitionEnabled","newDataGroupId","getData","oldSeries_1","oldData_1","batch","querySeries","finder","found","seriesIndex","seriesId","transitionSeriesFromOpt","transitionOpt","dimension","installUniversalTransition","registers","registerUpdateLifecycle","ecMOdel","seriesTransition","transOpt","ecModel","optionChanged","opt","updateBatches_1","keys","allSeries","getSeries","savedSeries","savedDataGroupIds","savedData"],"sources":["F:/idea_Project_2023/design_3/project/node_modules/echarts/lib/animation/universalTransition.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\n\nfunction getGroupIdDimension(data) {\n  var dimensions = data.dimensions;\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n\n    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {\n      return dimensions[i];\n    }\n  }\n}\n\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n\n      return;\n    }\n\n    var indices = data.getIndices();\n    var groupDim = getGroupIdDimension(data);\n\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        dataGroupId: seriesInfo.dataGroupId,\n        data: data,\n        dim: seriesInfo.dim || groupDim,\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\n\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\n\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\n\nfunction stopAnimation(el) {\n  el.stopAnimation();\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\n\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\n\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from ? // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n\n  function findKeyDim(items) {\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].dim) {\n        return items[i].dim;\n      }\n    }\n  }\n\n  var oldKeyDim = findKeyDim(oldDiffItems);\n  var newKeyDim = findKeyDim(newDiffItems);\n  var hasMorphAnimation = false;\n\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex; // TODO if specified dim\n\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      } // Use group id as transition key by default.\n      // So we can achieve multiple to multiple animation like drilldown / up naturally.\n      // If group id not exits. Use id instead. If so, only one to one transition will be applied.\n\n\n      var dataGroupId = diffItem.dataGroupId; // If specified key dimension(itemGroupId by default). Use this same dimension from other data.\n      // PENDING: If only use key dimension of newData.\n\n      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;\n      var dimInfo = keyDim && data.getDimensionInfo(keyDim);\n      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n\n      if (dimInfo) {\n        // Get from encode.itemGroupId.\n        var key = data.get(dimInfo.name, dataIndex);\n\n        if (dimOrdinalMeta) {\n          return dimOrdinalMeta.categories[key] || key + '';\n        }\n\n        return key + '';\n      } // Get groupId from raw item. { groupId: '' }\n\n\n      var itemVal = data.getRawDataItem(dataIndex);\n\n      if (itemVal && itemVal.groupId) {\n        return itemVal.groupId + '';\n      }\n\n      return dataGroupId || data.getId(dataIndex);\n    };\n  } // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n\n\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore\n\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.\n\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n\n    if ( // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n\n    if (newEl) {\n      stopAnimation(newEl);\n\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed\n\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n\n      if (oldEl) {\n        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.\n\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    } // else keep oldEl leaving animation.\n\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n\n  return seriesKey;\n}\n\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n\n  return seriesKey;\n}\n\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\n\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap(); // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.\n\n      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.\n\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        } // TODO check if data is same?\n\n\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\n\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n\n    if (found) {\n      return i;\n    }\n  }\n}\n\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        dim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        dim: finder.dimension\n      });\n    }\n  });\n\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\n\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.\n\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      } // Reset\n\n\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    } // Save all series of current update. Not only the updated one.\n\n\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData(); // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}