{"ast":null,"code":"import \"core-js/modules/esnext.typed-array.to-reversed.js\";\nimport \"core-js/modules/esnext.typed-array.to-sorted.js\";\nimport \"core-js/modules/esnext.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\nvar SeriesData = /** @class */\nfunction () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Global layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elements\n\n    this._graphicEls = []; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n    this._initGetDimensionInfo(needsHasOwn);\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx == null) {\n      return dim;\n    }\n    dimIdx = dim;\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    } // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n\n    var dimName = this._dimIdxToName.get(dimIdx);\n    if (dimName != null) {\n      return dimName;\n    }\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n    if (dim == null) {\n      return -1;\n    }\n    var dimInfo = this._getDimInfo(dim);\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n    var store;\n    if (data instanceof DataStore) {\n      store = data;\n    }\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n    this._store = store; // Reset\n\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n      start = _a.start,\n      end = _a.end;\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n    this._updateOrdinalMeta();\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n    var store = this._store;\n    var provider = store.getProvider();\n    this._updateOrdinalMeta();\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n        if (dataItem) {\n          var itemName = dataItem.name;\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n          var itemId = dataItem.id;\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n    if (name == null) {\n      name = '';\n    }\n    return name;\n  };\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n    var rawIndex = invertedIndices[value];\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n    var val = itemVisual[key];\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n      itemVisual[key] = val;\n    }\n    return val;\n  }; // eslint-disable-next-line\n\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n    this.__wrappedMethods = this.__wrappedMethods || [];\n    this.__wrappedMethods.push(methodName);\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n      return id;\n    };\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      return list;\n    };\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n        idList[idx] = id;\n      }\n    };\n  }();\n  return SeriesData;\n}();\nexport default SeriesData;","map":{"version":3,"names":["zrUtil","Model","DataDiffer","DefaultDataProvider","summarizeDimensions","SeriesDimensionDefine","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ORIGINAL","convertOptionIdName","isDataItemOption","setCommonECData","isSourceInstance","DataStore","isSeriesDataSchema","isObject","map","CtorInt32Array","Int32Array","Array","ID_PREFIX","INDEX_NOT_FOUND","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","prepareInvertedIndex","getId","getIdNameFromStore","normalizeDimensions","transferProperties","cloneListForMapAndSample","makeIdFromName","SeriesData","dimensionsInput","hostModel","type","_dimOmitted","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","dimensions","assignStoreDimIdx","isDimensionOmitted","_schema","dimensionInfos","dimensionNames","invertedIndicesMap","needsHasOwn","emptyObj","i","length","dimInfoInput","dimensionInfo","isString","name","dimensionName","coordDim","coordDimIndex","otherDims","push","createInvertedIndices","itemName","_nameDimIdx","itemId","_idDimIdx","process","env","NODE_ENV","assert","storeDimIndex","_dimInfos","_initGetDimensionInfo","_invertedIndicesMap","dimIdxToName_1","_dimIdxToName","createHashMap","each","dimName","set","prototype","getDimension","dim","dimIdx","_recognizeDimIndex","get","sourceDimDef","getSourceDimension","getDimensionIndex","dimInfo","_getDimInfo","getSourceDimensionIndex","isNumber","isNaN","_getStoreDimIndex","Error","getDimensionInfo","hasOwnProperty","undefined","getDimensionsOnCoord","_dimSummary","dataDimsOnCoord","slice","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","mapDimensionsAll","getStore","_store","initData","data","nameList","dimValueGetter","_this","store","provider","isArrayLike","property","_nameRepeatCount","_doInit","count","userOutput","appendData","range","appendValues","values","names","_a","start","end","shouldMakeIdFromName","_shouldMakeIdFromName","_updateOrdinalMeta","sourceIdx","ordinalMeta","collectOrdinalMeta","getProvider","getSource","sourceFormat","fillStorage","idList","isFormatOriginal","pure","sharedDataItem","dataItem","getItem","id","getApproximateExtent","getDataExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","value","extend","getName","rawIndex","getRawIndex","_getCategory","ordinal","getOrdinalMeta","categories","getByRawIndex","rawIdx","getIndices","getSum","getMedian","getValues","isArray","hasValue","dataDimIndicesOnCoord","len","indexOfName","indexOfRawIndex","rawIndexOf","invertedIndices","indicesOfNearest","maxDistance","cb","ctx","isFunction","fCtx","dimIndices","bind","filterSelf","filter","selectRange","innerRange","keys","mapArray","result","apply","arguments","ctxCompat","list","modify","isCalculationCoord","console","error","downSample","dimension","rate","sampleValue","sampleIndex","lttbDownSample","valueDimension","getRawDataItem","getItemModel","ecModel","diff","otherList","thisList","getVisual","visual","setVisual","kvObj","val","getItemVisual","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","setItemVisual","clearAllVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","setItemGraphicEl","el","seriesIndex","dataType","getItemGraphicEl","eachItemGraphicEl","context","call","cloneShallow","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","internalField","original","target","source","propName","clone","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt"],"sources":["F:/VUEProject/map-project/design_4/project/node_modules/echarts/lib/data/SeriesData.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\n\nvar SeriesData =\n/** @class */\nfunction () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Global layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elements\n\n    this._graphicEls = []; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n\n    this._initGetDimensionInfo(needsHasOwn);\n\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n\n\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx == null) {\n      return dim;\n    }\n\n    dimIdx = dim;\n\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    } // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n\n\n    var dimName = this._dimIdxToName.get(dimIdx);\n\n    if (dimName != null) {\n      return dimName;\n    }\n\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n\n\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n\n    if (dim == null) {\n      return -1;\n    }\n\n    var dimInfo = this._getDimInfo(dim);\n\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n\n\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n\n    var store;\n\n    if (data instanceof DataStore) {\n      store = data;\n    }\n\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n\n    this._store = store; // Reset\n\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n\n\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n\n\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n        start = _a.start,\n        end = _a.end;\n\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n\n    this._updateOrdinalMeta();\n\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n\n    var store = this._store;\n    var provider = store.getProvider();\n\n    this._updateOrdinalMeta();\n\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        if (dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n\n\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n\n\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n\n\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n\n\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n\n\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict'; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this; // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  }; // eslint-disable-next-line\n\n\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n\n\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      return list;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return SeriesData;\n}();\n\nexport default SeriesData;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}