{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param delta Move length.\n * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param handleIndex Can be 'all', means that both move the two handleEnds.\n * @param minSpan The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param maxSpan The range of dataZoom can not be larger than that.\n * @return The input handleEnds.\n */\nexport default function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n  if (handleIndex === 'all') {\n    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleSpan = restrict(handleSpan, [0, extentSpan]);\n    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);\n    handleIndex = 0;\n  }\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign;\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbidden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n  return handleEnds;\n}\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\nfunction restrict(value, extend) {\n  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));\n}","map":{"version":3,"names":["sliderMove","delta","handleEnds","extent","handleIndex","minSpan","maxSpan","extentSpan","restrict","Math","max","handleSpan","abs","originalDistSign","getSpanSign","extentMinSpan","realExtent","slice","sign","currDistSign","span","dist","value","extend","min","Infinity"],"sources":["F:/VUEProject/map-project/design_4/project/node_modules/echarts/lib/component/helper/sliderMove.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param delta Move length.\n * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param handleIndex Can be 'all', means that both move the two handleEnds.\n * @param minSpan The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param maxSpan The range of dataZoom can not be larger than that.\n * @return The input handleEnds.\n */\nexport default function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleSpan = restrict(handleSpan, [0, extentSpan]);\n    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);\n    handleIndex = 0;\n  }\n\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign;\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbidden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}