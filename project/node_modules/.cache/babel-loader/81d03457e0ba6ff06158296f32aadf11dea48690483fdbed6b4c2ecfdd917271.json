{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport { parsePercent } from '../util/number.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\nfunction getAxisKey(polar, axis) {\n  return axis.dim + polar.model.componentIndex;\n}\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var lastStackCoords = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var cx = seriesModel.coordinateSystem.cx;\n    var cy = seriesModel.coordinateSystem.cy;\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /* , baseDim */);\n\n    var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);\n    var valueAxisStart = valueAxis.dataToCoord(0);\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n      // Only ordinal axis can be stacked.\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart // Negative stack\n          };\n        } // Should also consider #4243\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n      var r0 = void 0;\n      var r = void 0;\n      var startAngle = void 0;\n      var endAngle = void 0; // radial sector\n\n      if (valueAxis.dim === 'radius') {\n        var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;\n        var angle = baseAxis.dataToCoord(baseValue);\n        if (Math.abs(radiusSpan) < barMinHeight) {\n          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n        }\n        r0 = baseCoord;\n        r = baseCoord + radiusSpan;\n        startAngle = angle - columnOffset;\n        endAngle = startAngle - columnWidth;\n        stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n      } // tangential sector\n      else {\n        var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;\n        var radius = baseAxis.dataToCoord(baseValue);\n        if (Math.abs(angleSpan) < barMinAngle) {\n          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n        }\n        r0 = radius + columnOffset;\n        r = r0 + columnWidth;\n        startAngle = baseCoord;\n        endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,\n        // add a round to differentiate it from origin\n        // let extent = angleAxis.getExtent();\n        // let stackCoord = angle;\n        // if (stackCoord === extent[0] && value > 0) {\n        //     stackCoord = extent[1];\n        // }\n        // else if (stackCoord === extent[1] && value < 0) {\n        //     stackCoord = extent[0];\n        // }\n\n        stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n      }\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        // Consider that positive angle is anti-clockwise,\n        // while positive radian of sector is clockwise\n        startAngle: -startAngle * Math.PI / 180,\n        endAngle: -endAngle * Math.PI / 180,\n        /**\n         * Keep the same logic with bar in catesion: use end value to\n         * control direction. Notice that if clockwise is true (by\n         * default), the sector will always draw clockwisely, no matter\n         * whether endAngle is greater or less than startAngle.\n         */\n        clockwise: startAngle >= endAngle\n      });\n    }\n  });\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\nfunction calRadialBar(barSeries) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\nexport default barLayoutPolar;","map":{"version":3,"names":["zrUtil","parsePercent","isDimensionStacked","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","polar","axis","dim","model","componentIndex","barLayoutPolar","seriesType","ecModel","api","lastStackCoords","barWidthAndOffset","calRadialBar","filter","getSeriesByType","isSeriesFiltered","coordinateSystem","type","eachSeriesByType","data","getData","baseAxis","getBaseAxis","axisKey","stackId","columnLayoutInfo","columnOffset","offset","columnWidth","width","valueAxis","getOtherAxis","cx","cy","barMinHeight","barMinAngle","valueDim","mapDimension","baseDim","stacked","clampLayout","valueAxisStart","dataToCoord","idx","len","count","value","baseValue","sign","baseCoord","p","n","r0","r","startAngle","endAngle","radiusSpan","angle","Math","abs","angleSpan","radius","setItemLayout","PI","clockwise","barSeries","columnsMap","each","axisExtent","getExtent","bandWidth","getBandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","barWidth","barMaxWidth","barGap","barCategoryGap","min","result","coordSysName","barGapPercent","autoWidth","max","column","stack","widthSum","lastColumn"],"sources":["F:/idea_Project_2023/design_3/project/node_modules/echarts/lib/layout/barPolar.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport { parsePercent } from '../util/number.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(polar, axis) {\n  return axis.dim + polar.model.componentIndex;\n}\n\nfunction barLayoutPolar(seriesType, ecModel, api) {\n  var lastStackCoords = {};\n  var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n  }));\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for polar only\n    if (seriesModel.coordinateSystem.type !== 'polar') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = polar.getOtherAxis(baseAxis);\n    var cx = seriesModel.coordinateSystem.cx;\n    var cy = seriesModel.coordinateSystem.cy;\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var barMinAngle = seriesModel.get('barMinAngle') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = isDimensionStacked(data, valueDim\n    /* , baseDim */\n    );\n    var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);\n    var valueAxisStart = valueAxis.dataToCoord(0);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in\n      // stackResultDimension directly.\n      // Only ordinal axis can be stacked.\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart // Negative stack\n\n          };\n        } // Should also consider #4243\n\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var r0 = void 0;\n      var r = void 0;\n      var startAngle = void 0;\n      var endAngle = void 0; // radial sector\n\n      if (valueAxis.dim === 'radius') {\n        var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;\n        var angle = baseAxis.dataToCoord(baseValue);\n\n        if (Math.abs(radiusSpan) < barMinHeight) {\n          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        r0 = baseCoord;\n        r = baseCoord + radiusSpan;\n        startAngle = angle - columnOffset;\n        endAngle = startAngle - columnWidth;\n        stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n      } // tangential sector\n      else {\n          var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;\n          var radius = baseAxis.dataToCoord(baseValue);\n\n          if (Math.abs(angleSpan) < barMinAngle) {\n            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n          }\n\n          r0 = radius + columnOffset;\n          r = r0 + columnWidth;\n          startAngle = baseCoord;\n          endAngle = baseCoord + angleSpan; // if the previous stack is at the end of the ring,\n          // add a round to differentiate it from origin\n          // let extent = angleAxis.getExtent();\n          // let stackCoord = angle;\n          // if (stackCoord === extent[0] && value > 0) {\n          //     stackCoord = extent[1];\n          // }\n          // else if (stackCoord === extent[1] && value < 0) {\n          //     stackCoord = extent[0];\n          // }\n\n          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n        }\n\n      data.setItemLayout(idx, {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        // Consider that positive angle is anti-clockwise,\n        // while positive radian of sector is clockwise\n        startAngle: -startAngle * Math.PI / 180,\n        endAngle: -endAngle * Math.PI / 180,\n\n        /**\n         * Keep the same logic with bar in catesion: use end value to\n         * control direction. Notice that if clockwise is true (by\n         * default), the sector will always draw clockwisely, no matter\n         * whether endAngle is greater or less than startAngle.\n         */\n        clockwise: startAngle >= endAngle\n      });\n    }\n  });\n}\n/**\n * Calculate bar width and offset for radial bar charts\n */\n\n\nfunction calRadialBar(barSeries) {\n  // Columns info on each category axis. Key is polar name\n  var columnsMap = {};\n  zrUtil.each(barSeries, function (seriesModel, idx) {\n    var data = seriesModel.getData();\n    var polar = seriesModel.coordinateSystem;\n    var baseAxis = polar.getBaseAxis();\n    var axisKey = getAxisKey(polar, baseAxis);\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = getSeriesStackId(seriesModel);\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n\n    if (barWidth && !stacks[stackId].width) {\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      stacks[stackId].width = barWidth;\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    barGap != null && (columnsOnAxis.gap = barGap);\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nexport default barLayoutPolar;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}